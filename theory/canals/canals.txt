Канал — это поток байтов
Когда мы говорим, что канал представляет собой поток байтов, мы имеем в виду следующее: при его использовании не существует понятия сообщений или их границ. Процесс,
считывающий данные из канала, может прочитать блок любого размера, независимо от
того, насколько большой блок был туда записан другим процессом. Кроме того, данные
проходят через канал последовательно — байты считываются из него в том же порядке,
в котором они были записаны. Произвольный доступ к содержимому канала с помощью
вызова lseek() невозможен.

    Реализацию принципа отдельных сообщений в канале следует делать на уровне приложения. Это вполне выполнимая задача (см. раздел 44.8), но для подобных целей лучше
применять другие IPC -механизмы, такие как очереди сообщений и датаграммные сокеты
(мы рассмотрим их в следующих главах).

Чтение из канала
    Любая попытка прочитать данные из пустого канала блокируется до тех пор, пока ктонибудь не запишет в этот канал хотя бы один байт. Если закрыть другой конец канала,
процесс, выполняющий чтение, получит конец файла (то есть операция r e a d () вернет 0),
как только дочитает оставшиеся данные.

Каналы являются однонаправленными
    Данные внутри канала могут перемещаться только в одном направлении. Один конец
канала используется для записи, а другой — для чтения.

Запись данных, чей объем не превышает PIPE_BUF байт,
является гарантированно атомарной

